Dynamic Pricing & Inventory Optimization Dashboard
Project Overview
This project is a full-fledged web application built with Django (Python) and a modern frontend (HTML, Tailwind CSS, JavaScript) that demonstrates dynamic pricing and inventory optimization for an e-commerce business. It integrates a simulated Machine Learning (ML) model for demand forecasting and suggested pricing, tracks historical product data, and visualizes trends using server-side generated charts (Matplotlib).
The application provides a centralized dashboard for managing products, viewing key metrics, and interacting with ML-driven insights.
Key Features
	•	Product Management Dashboard: View all products with their current price, suggested price, inventory, demand forecast, sales, and margin.
	•	Dynamic Pricing Simulation: Products have a suggested_price generated by a simulated ML model, which can be applied with a single click.
	•	Inventory Optimization Insights: Visual alerts for low stock and out-of-stock products based on demand forecasts.
	•	Historical Data Tracking: A dedicated ProductDailyRecord model stores daily snapshots of sales, inventory, and price for each product.
	•	Interactive ML Trigger: A button on the dashboard to manually trigger the ML prediction process, which updates forecasts and logs new daily records.
	•	Product Detail Pages: Click on any product to view its detailed overview and comprehensive historical charts (Sales, Price, Inventory) generated dynamically by Matplotlib.
	•	Manual Historical Data Input: Add or update historical sales records for any product directly from its detail page.
	•	User Authentication & Authorization: Secure login/logout functionality ensures only authenticated users can access the dashboard and perform operations.
	•	Responsive UI: Built with Tailwind CSS for a clean and adaptive user experience across different devices.
Technologies Used
	•	Backend:
	◦	Python 3.x
	◦	Django (Web Framework)
	◦	scikit-learn (for simulated ML model)
	◦	joblib (for saving/loading ML models)
	◦	matplotlib (for server-side chart generation)
	•	Frontend:
	◦	HTML5
	◦	Tailwind CSS (via CDN for simplicity, can be compiled locally)
	◦	Vanilla JavaScript (for dynamic interactions and API calls)
	•	Database:
	◦	SQLite (default Django database, easily swappable for PostgreSQL, MySQL, etc.)
	•	Development Environment:
	◦	Virtual Environment (venv)
	◦	VS Code (recommended IDE)
Setup Instructions
Follow these steps to get the project up and running on your local machine.
1. Clone the Repository (or create project manually)
If you're starting from scratch, create a directory and follow the manual setup:
mkdir dynamic_pricing_django
cd dynamic_pricing_django

2. Set up Virtual Environment
It's highly recommended to use a virtual environment to manage project dependencies.
python -m venv venv

3. Activate the Virtual Environment
	•	On Windows (PowerShell):.\venv\Scripts\Activate.ps1
	•	
	•	
	•	On Windows (Command Prompt):.\venv\Scripts\activate.bat
	•	
	•	
	•	On macOS/Linux:source venv/bin/activate
	•	
	•	(You should see (venv) at the beginning of your terminal prompt.)
4. Install Dependencies
Install Django, scikit-learn, joblib, and matplotlib:
pip install Django scikit-learn joblib matplotlib

5. Create Django Project and App Structure
If you haven't already, create the Django project and app.
# Create the Django project in the current directory
django-admin startproject myproject .

# Create the dashboard_app
python manage.py startapp dashboard_app

6. Configure Django Settings
Open myproject/settings.py and make the following changes:
	•	Add dashboard_app to INSTALLED_APPS:INSTALLED_APPS = [
	•	    # ... other apps
	•	    'dashboard_app',
	•	]
	•	
	•	
	•	Configure TEMPLATES DIRS:TEMPLATES = [
	•	    {
	•	        'BACKEND': 'django.template.backends.django.DjangoTemplates',
	•	        'DIRS': [os.path.join(BASE_DIR, 'templates')], # Add this line
	•	        'APP_DIRS': True,
	•	        'OPTIONS': {
	•	            'context_processors': [
	•	                'django.template.context_processors.debug',
	•	                'django.template.context_processors.request',
	•	                'django.contrib.auth.context_processors.auth',
	•	                'django.contrib.messages.context_processors.messages',
	•	            ],
	•	        },
	•	    },
	•	]
	•	
	•	
	•	Add Authentication Redirect URLs (at the bottom of the file):LOGIN_REDIRECT_URL = '/'
	•	LOGOUT_REDIRECT_URL = '/accounts/login/'
	•	
	•	
7. Create dashboard_app Subdirectories and Files
Ensure the following directories and empty __init__.py files exist to make them Python packages:
dashboard_app/
├── ml_logic/
│   └── __init__.py  (empty file)
├── management/
│   └── commands/
│       └── __init__.py (empty file)
└── __init__.py (already exists)

8. Populate Core Files with Code
Copy the code for each file from the corresponding immersive artifacts provided in our conversation.
	•	dashboard_app/models.py:
	◦	Copy from: dashboard_app/models.py (with History Model)
	•	dashboard_app/admin.py:
	◦	Copy from: dashboard_app/admin.py (with History Model)
	•	dashboard_app/ml_logic/ml_model_service.py:
	◦	Rename dashboard_app/ml_logic/ml_model_simulator.py to ml_model_service.py if it exists.
	◦	Copy from: dashboard_app/ml_logic/ml_model_service.py
	•	dashboard_app/management/commands/run_ml_predictions.py:
	◦	Copy from: dashboard_app/management/commands/run_ml_predictions.py (using Trained ML Model)
	•	dashboard_app/views.py:
	◦	Copy from: dashboard_app/views.py (Complete and Correct)
	•	dashboard_app/urls.py:
	◦	Create this file if it doesn't exist.
	◦	Copy from: dashboard_app/urls.py (with Dynamic Chart URL)
	•	dashboard_app/templatetags/custom_filters.py:
	◦	Create dashboard_app/templatetags/ and an empty __init__.py inside it.
	◦	Create custom_filters.py inside templatetags/.
	◦	Copy from: dashboard_app/templatetags/custom_filters.py
9. Create Templates Directory and Files
Ensure the templates directory exists at your project root (dynamic_pricing_django/).
templates/
├── dashboard.html
└── registration/
    ├── login.html
    └── logged_out.html

	•	templates/dashboard.html:
	◦	Copy from: templates/dashboard.html (with ML Feedback)
	•	templates/product_detail.html:
	◦	Copy from: templates/product_detail.html (with Dynamic Matplotlib Charts)
	•	templates/registration/login.html:
	◦	Copy from: templates/registration/login.html
	•	templates/registration/logged_out.html:
	◦	Copy from: templates/registration/logged_out.html
10. Apply Database Migrations
This creates the necessary tables in your SQLite database.
python manage.py makemigrations
python manage.py migrate

11. Create a Superuser
This allows you to log into the Django admin and your dashboard.
python manage.py createsuperuser

Follow the prompts to set up a username, email, and password.
How to Use the Application
1. Start the Django Development Server
In your terminal (with virtual environment active):
python manage.py runserver

The application will be accessible at http://127.0.0.1:8000/.
2. Log In
Navigate to http://127.0.0.1:8000/. You will be redirected to the login page. Use the superuser credentials you created.
3. Populate Initial Product Data (Crucial!)
Before using ML predictions or charts, you need some data.
	•	Go to the Django Admin: http://127.0.0.1:8000/admin/
	•	Log in.
	•	Under "DASHBOARD APP", click on "Products".
	•	Click "Add Product" and add at least 5 products with varied data (e.g., sales_last_7_days, current_price, competitor_price). Use unique id values like prod001, prod002, etc.
4. Generate Initial ML Predictions & Historical Data
This will train the ML model and create initial historical records.
	•	In your terminal, run the ML command:python manage.py run_ml_predictions
	•	
	•	
	•	Run this command a few times (e.g., 2-3 times over a few minutes) to generate more varied historical data for your charts.
5. Explore the Dashboard
	•	Go to http://127.0.0.1:8000/.
	•	Product Table: See your products with ML-generated Suggested Price and Demand Forecast.
	•	"Run ML Predictions" Button: Click this button in the "Performance Analytics" section. It will trigger the ML process on the backend, update the database, and refresh the dashboard with new predictions.
	•	Product Detail Pages: Click on any product name in the table to go to its dedicated detail page. Here, you'll see:
	◦	Detailed product overview.
	◦	Sales History, Price History, and Inventory History charts generated by Matplotlib.
	◦	"Add/Update Historical Sales" form: Use this to manually add historical sales data for a specific date. After adding, the charts will dynamically update.
6. Log Out
Click the "Logout" button in the header to end your session.
Project Structure
dynamic_pricing_django/
├── venv/                       # Python Virtual Environment
├── dashboard_app/              # Django Application
│   ├── migrations/             # Database migrations
│   ├── ml_logic/               # Contains ML model service (ml_model_service.py)
│   ├── management/             # Contains custom Django management commands
│   │   └── commands/
│   │       └── run_ml_predictions.py # Command to run ML predictions and log history
│   ├── templatetags/           # Custom Django template filters
│   │   └── custom_filters.py
│   ├── admin.py                # Django Admin configuration
│   ├── models.py               # Database models (Product, ProductDailyRecord)
│   ├── urls.py                 # App-specific URL routes
│   └── views.py                # Logic for web pages and API endpoints
├── myproject/                  # Django Project Configuration
│   ├── settings.py             # Main project settings
│   └── urls.py                 # Project-level URL routes
├── templates/                  # HTML templates directory
│   ├── dashboard.html          # Main dashboard page
│   ├── product_detail.html     # Individual product detail page
│   └── registration/           # Django authentication templates
│       ├── login.html
│       └── logged_out.html
└── manage.py                   # Django's command-line utility

Future Enhancements
	•	Interactive Client-Side Charts: Revert to Chart.js (or similar) for interactive charts (zoom, pan, tooltips) on the frontend, fetching data via new API endpoints.
	•	Advanced ML Models: Implement more sophisticated ML models (e.g., ARIMA, Prophet for time series forecasting; XGBoost/Random Forest for pricing) with more features (seasonality, promotions, external factors).
	•	ML Model Management: Add features to track model versions, retrain models on new data, and display model performance metrics (MAE, RMSE).
	•	User Management: Allow users to register, manage their profiles, and assign different roles/permissions.
	•	Product CRUD: Implement full Create, Read, Update, Delete (CRUD) functionality for products directly from the UI.
	•	Bulk Data Operations: Add CSV/Excel import/export for products and historical data.
	•	Asynchronous Tasks: Use Celery to run long-running ML prediction tasks in the background, preventing server blocking.
	•	Real-time Updates: Implement WebSockets (e.g., Django Channels) for real-time updates to the dashboard without requiring a page reload.
	•	Notifications: Implement a more robust notification system for alerts (e.g., email, in-app notifications).
	•	Deployment: Deploy the application to a cloud platform (e.g., Heroku, AWS, Google Cloud).
